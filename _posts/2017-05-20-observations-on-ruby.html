---
layout: post
title: Observations on Ruby
excerpt: Looking back at a language I've leapfrogged
---

<p>
I recently had to interview a candidate who used Ruby, so I prepared a question and implemented a solution in Ruby. Before I could tackle the problem itself, however, I had to first learn Ruby, a language I'd brushed up against many times in the past but never learned.
</p>

<p>
The first hour, of course, was spent setting up Emacs. I largely copied the <a href="https://github.com/bbatsov/prelude/blob/master/modules/prelude-ruby.el">Ruby configs of Prelude</a>, a popular Emacs "starter kit".
</p>

<p>
After that, I dove into the finer points of the Ruby language. Here are some observations:
</p>

<ul class="org-ul">
<li>Syntax is nice for a non-Lisp
</li>
<li>Community is large, so there are a lot of answers to basic questions on platforms like StackOverflow
</li>
<li>Documentation is good
</li>
<li>Function style is encouraged: <code>map</code> instead of <code>for</code>, etc.
</li>
<li>Missing the basics of "true" functional languages, e.g. immutable data structures
</li>
</ul>

<p>
Overall, Ruby is a nice language, but I can see why some in Ruby community have embraced Clojure. Clojure takes many of the nice things about Ruby&#x2013;reasonable syntax, functional style, etc.&#x2013;further than Ruby does or ever will. Bozhidar made the same point in a <a href="https://speakerdeck.com/bbatsov/ruby-4-dot-0-to-infinity-and-beyond-rubyconf-dot-by-2017">presentation on Ruby 4.0</a>, in which he argues that languages like Clojure and <a href="http://elixir-lang.org/">Elixir</a> are the "next-gen" Ruby.
</p>

<p>
Discussions with colleagues and friends have convinced me that functional programming is still a very niche thing. In the meantime, languages like Ruby can gently nudge people in the right direction.
</p>
